// ==UserScript==
// @name         OpenPhone AI Summarizer (Userscript)
// @namespace    https://github.com/ilakskills/
// @version      57.2
// @description  Final stable build with all functions and CSS unabridged. Full multi-model, vision, chat, and ZIP export.
// @author       ilakskills
// @match        https://my.openphone.com/inbox/*
// @require      https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js
// @grant        GM_addStyle
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_xmlhttpRequest
// @grant        GM_setClipboard
// ==/UserScript==

(function() {
    'use strict';

    // --- MASTER PROMPT & CONFIGURATION ---
    const PROMPT_SECTIONS = {
        title: `Title:\nDescribe the main meeting purpose or project discussed. Use details from any provided images to be more specific (e.g., "Network Rack Installation", "Server Troubleshooting Session").`,
        attendees: `Attendees:\nList names, inferred roles, and companies. Use phone numbers if names are unavailable.`,
        project_topic: `Project/Topic:\nClearly state the main project or work order. Include relevant IDs (WO#, Ticket#) and describe equipment seen in images.`,
        discussion_points: `Content/Key Discussion Points:\nBulleted list summarizing the core conversation. Synthesize related points.`,
        decisions: `Decisions Made:\nBulleted list of explicit agreements or conclusions reached.`,
        action_items: `Follow-Up Tasks / Action Items:\nClear, actionable bullet points, assigned to a person/role with deadlines if mentioned.`,
        notes: `Notes/Observations (Optional):\nInclude observations about tone, potential risks, or unresolved questions.`,
        quick_summary: `Quick Summary: Sum it all up into 2 or 3 easy to understand sentences.`,
        quick_next_steps: `Quick Next Steps: Outline next steps in 2 or 3 easy to understand sentences.`,
        disclaimer: `Disclaimer:\n"Generated by AI. Please review for accuracy."`
    };
    const BASE_PROMPT_HEADER = `Goal:\nTransform a potentially messy conversation log...`;
    const BASE_PROMPT_FOOTER = `? How I Work:\n... Analyze Images: If images are provided, incorporate details from them into your summary...`;
    const GEMINI_KEY_NAME = 'gemini_api_key_storage_tm';
    const OPENAI_KEY_NAME = 'openai_api_key_storage_tm';
    const AUTH_COOKIE_NAME = 'openphone_auth_token';
    const IMAGE_ANALYSIS_PROMPT = `You are an expert at analyzing technical images from the field. Your task is to analyze the following image(s) and return a structured JSON object.\n1. For EACH image, provide a detailed, one-sentence 'description'.\n2. For EACH image, provide a short, descriptive 'suggested_filename' in snake_case format (e.g., 'network_rack_before', 'server_error_screen').\n3. Provide a single, overall 'suggested_zip_suffix' that summarizes the main theme of all images combined.\n\nYour entire response MUST be ONLY the JSON object, with no other text before or after it.\n\nExample JSON format for 2 images:\n{\n  "image_details": [\n    {\n      "description": "A technician is holding a newly installed network switch in a server rack.",\n      "suggested_filename": "switch_installation_complete"\n    },\n    {\n      "description": "A close-up of a network cable being plugged into a patch panel.",\n      "suggested_filename": "patch_panel_connection"\n    }\n  ],\n  "suggested_zip_suffix": "network_switch_installation"\n}`;

    const MODELS = [
        { id: 'gemini-1.5-flash-latest', family: 'gemini', displayName: 'Gemini 1.5 Flash', description: 'Best for speed & value.', price: '~$0.35 / 1M tokens' },
        { id: 'gpt-4o', family: 'openai', displayName: 'GPT-4o', description: 'Flagship - Fast, multimodal, balanced cost.', price: '~$5.00 / 1M tokens' },
        { id: 'gpt-4-turbo', family: 'openai', displayName: 'GPT-4 Turbo', description: 'Powerful & reliable for complex tasks.', price: '~$10.00 / 1M tokens' },
        { id: 'gpt-4', family: 'openai', displayName: 'GPT-4 (Classic)', description: 'Highest quality, for maximum effort.', price: '~$30.00 / 1M tokens' },
        { id: 'gpt-3.5-turbo', family: 'openai', displayName: 'GPT-3.5 Turbo', description: 'Ultra-fast & most economical.', price: '~$0.50 / 1M tokens' },
    ];

    // --- SVG Icons ---
    const sparkleIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="white" d="M12 2.5a.75.75 0 0 1 .75.75V5a.75.75 0 0 1-1.5 0V3.25A.75.75 0 0 1 12 2.5zm0 14a.75.75 0 0 1 .75.75v1.75a.75.75 0 0 1-1.5 0V17.5a.75.75 0 0 1 .75-.75zM6.22 5.47a.75.75 0 0 1 1.06 0l1.25 1.25a.75.75 0 0 1-1.06 1.06L6.22 6.53a.75.75 0 0 1 0-1.06zm8.94 8.94a.75.75 0 0 1 1.06 0l1.25 1.25a.75.75 0 0 1-1.06 1.06l-1.25-1.25a.75.75 0 0 1 0-1.06zM2.5 11.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5a.75.75 0 0 1 .75-.75zm18.5.75a.75.75 0 0 0 1.5 0v-1.5a.75.75 0 0 0-1.5 0v1.5zM6.22 15.22a.75.75 0 0 1 0-1.06l1.25-1.25a.75.75 0 0 1 1.06 1.06l-1.25 1.25a.75.75 0 0 1-1.06 0zM15.22 6.22a.75.75 0 0 1 0-1.06l1.25-1.25a.75.75 0 1 1 1.06 1.06l-1.25 1.25a.75.75 0 0 1-1.06 0z"></path></svg>`;
    const settingsIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 20 20"><path fill="currentColor" d="M10.667 1.875A.833.833 0 0 0 10 1.25a.833.833 0 0 0-.667.625l-.234.937a5.218 5.218 0 0 0-1.593.84l-.87-.39a.833.833 0 0 0-.933.277L4.29 5.293a.833.833 0 0 0 .278.933l.794.516a5.233 5.233 0 0 0 0 1.916l-.794.516a.833.833 0 0 0-.278.933l1.414 1.414a.833.833 0 0 0 .933.278l.87-.39c.47.318.99.577 1.592.839l.234.937A.833.833 0 0 0 10 18.75a.833.833 0 0 0 .667-.625l-.234-.937c.603-.262 1.122-.521 1.593-.84l.87.39a.833.833 0 0 0 .933-.277l1.414-1.414a.833.833 0 0 0-.278-.933l-.794-.516a5.233 5.233 0 0 0 0-1.916l.794-.516a.833.833 0 0 0 .278-.933L15.707 3.88a.833.833 0 0 0-.933-.278l-.87.39a5.218 5.218 0 0 0-1.592-.84l-.234-.937zM10 12.5a2.5 2.5 0 1 1 0-5a2.5 2.5 0 0 1 0 5z"></path></svg>`;
    const sendIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="currentColor" d="M2.525 2.525a.75.75 0 0 1 .91-.073l13.5 6.75a.75.75 0 0 1 0 1.196l-13.5 6.75a.75.75 0 0 1-1.002-1.123L3.89 10 2.433 3.571a.75.75 0 0 1 .092-1.046z"></path></svg>`;

    // --- TAMPERMONKEY HELPER FUNCTIONS ---
    function gmFetch(url, options = {}) {
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: options.method || 'GET',
                url: url,
                headers: options.headers,
                data: options.body,
                responseType: options.responseType,
                timeout: 30000, // 30-second timeout
                onload: (response) => {
                    const mockResponse = {
                        ok: response.status >= 200 && response.status < 300,
                        status: response.status,
                        statusText: response.statusText,
                        url: response.finalUrl,
                        response: response.response,
                        responseText: response.responseText,
                        json: async () => (typeof response.response === 'object' ? response.response : JSON.parse(response.responseText)),
                        text: async () => response.responseText,
                        blob: async () => (response.responseType === 'blob' ? response.response : new Blob([response.response]))
                    };
                    resolve(mockResponse);
                },
                onerror: (error) => reject(new Error('GM_xmlhttpRequest network error')),
                ontimeout: () => reject(new Error('GM_xmlhttpRequest timeout'))
            });
        });
    }

    // --- UI HELPER FUNCTIONS ---
    const injectStyles = () => {
        GM_addStyle(`
            .floating-ai-button-container { position: fixed !important; bottom: 30px !important; right: 30px !important; z-index: 999999 !important; display: flex; align-items: center; background: #007bff; border-radius: 50px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
            .floating-ai-main-btn { background: transparent; border: none; padding: 12px 16px; cursor: pointer; display: flex; align-items: center; color: white; font-weight: 500; font-size: 16px; gap: 8px; }
            .floating-ai-settings-btn { background: rgba(255,255,255,0.2); border: none; border-left: 1px solid rgba(255,255,255,0.3); padding: 8px; cursor: pointer; color: white; display:flex; align-items:center; border-top-right-radius: 50px; border-bottom-right-radius: 50px; }
            .floating-ai-settings-btn:hover { background: rgba(0,0,0,0.2); }
            .gemini-modal-overlay { position: fixed !important; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 999998 !important; display: flex; align-items: center; justify-content: center; user-select:text;-webkit-user-select:text}
            .gemini-modal-content { background-color: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); width: 90%; max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; }
            .gemini-modal-header { padding: 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; } .gemini-modal-header h2 { margin: 0; font-size: 18px; color: #333; }
            .gemini-modal-close { font-size: 24px; font-weight: bold; cursor: pointer; color: #888; border: none; background: none; }
            .gemini-modal-body { padding: 16px; overflow-y: auto; font-family: sans-serif; flex-grow: 1; line-height: 1.5; white-space: normal; background-color: #fff; }
            .gemini-modal-footer { padding: 12px 16px; border-top: 1px solid #e0e0e0; display: flex; gap: 10px; justify-content: flex-end; }
            .gemini-modal-button { padding: 8px 16px; border-radius: 6px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; font-weight: 500; } .gemini-modal-button:hover { background-color: #e0e0e0; } .gemini-modal-button.primary { background-color: #007bff; color: white; border-color: #007bff; }
            .gemini-modal-button.primary:hover { background-color: #0056b3; } .gemini-modal-button.active { border-color: #007bff; background-color: #cce5ff; }
            .gemini-toast { position: fixed !important; top: 20px; right: 20px; background-color: #333; color: white; padding: 12px 20px; border-radius: 6px; z-index: 1000000 !important; font-size: 14px; transition: opacity 0.5s; opacity: 1; }
            .settings-section { margin-bottom: 20px; } .settings-section h3 { margin:0 0 10px; border-bottom: 1px solid #eee; padding-bottom: 5px; } .settings-section label { display: block; margin-bottom: 5px; font-weight: bold; }
            .settings-section input[type="text"], .settings-section textarea { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-family: sans-serif; } .date-filters button { margin-right: 5px; }
            .sections-grid, .model-selection-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; } .model-selection-grid label { font-weight: normal; } .sections-grid label { font-weight: normal; }
            .model-selection-grid div { display: flex; flex-direction: column; } .model-selection-grid label { display: flex; align-items: center; } .model-selection-grid .model-desc { font-size: 12px; color: #666; padding-left: 25px; margin-top: -5px; }
            .chat-log { display: flex; flex-direction: column; gap: 12px; }
            .message-bubble { padding: 10px 14px; border-radius: 18px; max-width: 80%; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
            .message-bubble.user { background-color: #007bff; color: white; align-self: flex-end; } .message-bubble.model { background-color: #e9e9eb; color: #1c1c1e; align-self: flex-start; } .message-bubble.loading { align-self: flex-start; } .message-bubble.error { background-color: #ffcccc; color: #a00; }
            .chat-input-form { display: flex; gap: 10px; padding: 10px 16px; border-top: 1px solid #e0e0e0; } #chat-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 20px; } #chat-send-btn { background: #007bff; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; }
        `);
    };

    const showToast = (message, type = 'success') => {
        const toast = document.createElement('div');
        toast.className = `gemini-toast ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 500);
        }, 3000);
    };

    const manageApiKeys = async () => {
        const geminiKey = await GM_getValue(GEMINI_KEY_NAME, "");
        const newGeminiKey = prompt("Enter your Gemini API Key:", geminiKey);
        if (newGeminiKey !== null) {
            newGeminiKey.trim() ? await GM_setValue(GEMINI_KEY_NAME, newGeminiKey.trim()) : await GM_setValue(GEMINI_KEY_NAME, "");
        }
        const openaiKey = await GM_getValue(OPENAI_KEY_NAME, "");
        const newOpenAIKey = prompt("Enter your OpenAI API Key:", openaiKey);
        if (newOpenAIKey !== null) {
            newOpenAIKey.trim() ? await GM_setValue(OPENAI_KEY_NAME, newOpenAIKey.trim()) : await GM_setValue(OPENAI_KEY_NAME, "");
        }
        showToast("API Keys updated!", "success");
    };

    const markdownToHtml = (text) => {
        let html = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\*\*(.*?)\*\*|__(.*?)__/g, "<strong>$1$2</strong>").replace(/\*(.*?)\*|_(.*?)_/g, "<em>$1$2</em>").replace(/^### (.*$)/gim, "<h3>$1</h3>").replace(/^## (.*$)/gim, "<h2>$1</h2>").replace(/^# (.*$)/gim, "<h1>$1</h1>").replace(/\n/g, "<br>");
        html = html.replace(/^\s*[-*] (.*)/gim, '<ul><li>$1</li></ul>').replace(/<\/ul>\s*<br\s*\/?>\s*<ul>/g, "");
        return html;
    };

    const downloadSummaryAsZip = async (summaryText, filename, imageInfo) => {
        try {
            // Check if JSZip is available
            if (!window.JSZip) {
                throw new Error("JSZip library not loaded. Please check your internet connection or the @require directive.");
            }

            showToast("Preparing ZIP file...", "success");
            const zip = new window.JSZip();
            zip.file("summary.txt", summaryText);

            if (imageInfo && imageInfo.length > 0) {
                const imgFolder = zip.folder("images");
                const authToken = await getAuthToken(); // Get the auth token for image requests
                const imageFetchPromises = imageInfo.map(async (info) => {
                    try {
                        // Validate URL
                        if (!info.url.startsWith('http')) {
                            throw new Error(`Invalid image URL: ${info.url}`);
                        }
                        // Fetch image with auth headers
                        const response = await gmFetch(info.url, {
                            responseType: 'blob',
                            headers: { Authorization: authToken }
                        });
                        if (!response.ok) {
                            throw new Error(`Failed to fetch image: ${info.url} (Status: ${response.status})`);
                        }
                        const blob = response.response;
                        // Ensure the filename has a valid extension based on MIME type
                        const extension = info.newName.split('.').pop().toLowerCase();
                        if (!['jpg', 'jpeg', 'png', 'gif'].includes(extension)) {
                            console.warn(`Invalid image extension for ${info.newName}. Defaulting to .jpg`);
                            info.newName = info.newName.replace(/\.[^/.]+$/, '.jpg');
                        }
                        imgFolder.file(info.newName, blob);
                    } catch (e) {
                        console.error(`Error fetching image ${info.url}:`, e);
                        showToast(`Skipped image ${info.newName} due to fetch error.`, "error");
                    }
                });
                await Promise.all(imageFetchPromises);
            }

            // Generate the ZIP file
            const content = await zip.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: { level: 6 }
            });

            // Sanitize filename
            const sanitizedFilename = filename
                .replace(".txt", ".zip")
                .replace(/[^\w\s-.]/g, "")
                .replace(/\s+/g, "-");

            // Trigger download
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = sanitizedFilename;
            link.click();
            URL.revokeObjectURL(link.href);
            showToast("ZIP file downloaded successfully!", "success");
        } catch (e) {
            console.error("ZIP creation failed:", e);
            showToast(`Failed to create ZIP file: ${e.message}`, "error");
        }
    };

    const copyRichText = (htmlContent, plainTextContent) => {
        try {
            const blobHtml = new Blob([htmlContent], { type: "text/html" });
            const blobText = new Blob([plainTextContent], { type: "text/plain" });
            navigator.clipboard.write([new ClipboardItem({ "text/html": blobHtml, "text/plain": blobText })])
                .then(() => showToast("Formatted summary copied!"))
                .catch(err => {
                    console.error("Rich text copy failed, falling back to plain text:", err);
                    GM_setClipboard(plainTextContent, "text");
                    showToast("Copied as plain text.");
                });
        } catch (error) {
            console.error("Error creating ClipboardItem, falling back to plain text:", error);
            GM_setClipboard(plainTextContent, "text");
            showToast("Copied as plain text.");
        }
    };

    const showExecutionOptionsModal = () => {
        const modal = document.createElement("div");
        modal.className = "gemini-modal-overlay options-modal";
        const defaultSections = ["title", "quick_summary", "quick_next_steps"];
        const sectionsHtml = Object.keys(PROMPT_SECTIONS).map(key => {
            const isChecked = defaultSections.includes(key);
            const label = key.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
            return `<label><input type="checkbox" name="section" value="${key}" ${isChecked ? "checked" : ""}>${label}</label>`;
        }).join("");
        const modelsHtml = MODELS.map((model, index) =>
            `<div><label><input type="radio" name="model" value="${model.id}" ${index === 0 ? "checked" : ""}> ${model.displayName}</label><div class="model-desc">${model.description} | ${model.price}</div></div>`
        ).join("");
        modal.innerHTML = `<div class="gemini-modal-content"><div class="gemini-modal-header"><h2>Generate Summary Options</h2><button class="gemini-modal-close">×</button></div><div class="gemini-modal-body"><div class="settings-section"><h3>Custom Instructions (One-time)</h3><textarea id="custom-instructions" rows="3" style="width:100%;font-family:inherit;padding:8px" placeholder="e.g., Act as a project manager. Focus on billing issues."></textarea></div><div class="settings-section"><h3>AI-Powered Date Filter</h3><div class="date-filters"><button class="gemini-modal-button" data-filter="today">Today</button><button class="gemini-modal-button" data-filter="yesterday">Yesterday</button><button class="gemini-modal-button" data-filter="week">This Week</button><button class="gemini-modal-button" data-filter="last_week">Last Week</button><button class="gemini-modal-button active" data-filter="all">All Available</button></div></div><div class="settings-section"><h3>AI Model</h3><div class="model-selection-grid">${modelsHtml}</div></div><div class="settings-section"><h3>Output Sections</h3><div class="sections-grid">${sectionsHtml}</div></div></div><div class="gemini-modal-footer"><button class="gemini-modal-button" id="cancel-run">Cancel</button><button class="gemini-modal-button primary" id="generate-summary">Generate Summary</button></div></div>`;
        document.body.appendChild(modal);
        const closeModal = () => modal.remove();
        modal.querySelector(".gemini-modal-close").addEventListener("click", closeModal);
        modal.querySelector("#cancel-run").addEventListener("click", closeModal);
        const dateButtons = modal.querySelectorAll(".date-filters button");
        let activeDateFilter = "all";
        dateButtons.forEach(button => {
            button.addEventListener("click", () => {
                dateButtons.forEach(btn => btn.classList.remove("active"));
                button.classList.add("active");
                activeDateFilter = button.dataset.filter;
            });
        });
        modal.querySelector("#generate-summary").addEventListener("click", () => {
            const selectedModel = modal.querySelector('input[name="model"]:checked').value;
            const selectedSections = Array.from(modal.querySelectorAll('input[name="section"]:checked')).map(cb => cb.value);
            const customInstructions = modal.querySelector("#custom-instructions").value;
            if (selectedSections.length > 0) {
                closeModal();
                runSummaryProcess(selectedModel, selectedSections, customInstructions, activeDateFilter);
            } else {
                showToast("Please select at least one output section.", "error");
            }
        });
    };

    const showChatModal = (initialHistory, filename, modelId, imageInfo) => {
        let chatHistory = [...initialHistory];
        const overlay = document.createElement("div");
        overlay.className = "gemini-modal-overlay chat-modal";
        overlay.innerHTML = `<div class="gemini-modal-content"><div class="gemini-modal-header"><h2>AI Summary & Refinement</h2><button class="gemini-modal-close">×</button></div><div class="gemini-modal-body" style="background-color:white;"><div class="chat-log"></div></div><form class="chat-input-form"><input type="text" id="chat-input" placeholder="Refine the summary..." autocomplete="off"><button type="submit" id="chat-send-btn" title="Send">${sendIconSVG}</button></form><div class="gemini-modal-footer"><button class="gemini-modal-button download-btn">Download .ZIP</button><button class="gemini-modal-button primary copy-btn">Copy as Rich Text</button></div></div>`;
        document.body.appendChild(overlay);
        const chatLog = overlay.querySelector(".chat-log");
        const chatInput = overlay.querySelector("#chat-input");
        const chatForm = overlay.querySelector(".chat-input-form");
        const closeModal = () => overlay.remove();
        const appendMessage = (sender, text) => {
            const bubble = document.createElement("div");
            bubble.className = `message-bubble ${sender}`;
            if (sender === "model") {
                bubble.innerHTML = markdownToHtml(text);
            } else {
                bubble.textContent = text;
            }
            chatLog.appendChild(bubble);
            chatLog.scrollTop = chatLog.scrollHeight;
            return bubble;
        };
        const initialAiResponse = chatHistory.find(h => h.role === "model")?.parts[0]?.text;
        if (initialAiResponse) appendMessage("model", initialAiResponse);
        const sendChatMessage = async message => {
            appendMessage("user", message);
            chatInput.value = "";
            const loadingBubble = appendMessage("model loading", "...");
            chatHistory.push({ role: "user", parts: [{ text: message }] });
            try {
                let apiUrl, apiKey, payload, headers;
                const modelInfo = MODELS.find(m => m.id === modelId);
                if (modelInfo.family === "gemini") {
                    apiKey = await GM_getValue(GEMINI_KEY_NAME, "");
                    apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                    payload = { contents: chatHistory };
                    headers = { "Content-Type": "application/json" };
                } else {
                    apiKey = await GM_getValue(OPENAI_KEY_NAME, "");
                    apiUrl = "https://api.openai.com/v1/chat/completions";
                    const openAiMessages = chatHistory.map(({ role, parts }) => ({
                        role: role === "model" ? "assistant" : role,
                        content: parts.map(p => p.text).join('\n')
                    }));
                    payload = { model: modelId, messages: openAiMessages, max_tokens: 4096 };
                    headers = { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` };
                }
                const response = await gmFetch(apiUrl, { method: "POST", headers: headers, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API Error: ${await response.text()}`);
                const data = await response.json();
                const newText = modelInfo.family === "gemini" ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
                if (!newText) throw new Error("Received an empty response from AI.");
                chatHistory.push({ role: "model", parts: [{ text: newText }] });
                loadingBubble.remove();
                appendMessage("model", newText);
            } catch (error) {
                loadingBubble.remove();
                appendMessage("error", `Error: ${error.message}`);
                console.error(error);
            }
        };
        chatForm.addEventListener("submit", e => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) sendChatMessage(message);
        });
        overlay.querySelector(".gemini-modal-close").addEventListener("click", closeModal);
        overlay.querySelector(".copy-btn").addEventListener("click", () => {
            const lastModelBubble = chatLog.querySelector(".message-bubble.model:last-child");
            if (lastModelBubble) copyRichText(lastModelBubble.innerHTML, lastModelBubble.textContent);
        });
        overlay.querySelector(".download-btn").addEventListener("click", () => downloadSummaryAsZip(chatLog.querySelector(".message-bubble.model:last-child")?.textContent || "", filename, imageInfo));
    };

    // --- CORE LOGIC ---
    const getCookie = name => {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
    };

    const setCookie = (name, value, days = 7) => {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = `${name}=${value || ""}${expires}; path=/`;
    };

    const getAuthToken = () => {
        return new Promise((resolve, reject) => {
            const cookieToken = getCookie(AUTH_COOKIE_NAME);
            if (cookieToken) return resolve(cookieToken);
            let capturedAuthToken = null;
            const originalFetch = window.fetch;
            const originalXhrSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
            const cleanup = () => {
                window.fetch = originalFetch;
                XMLHttpRequest.prototype.setRequestHeader = originalXhrSetRequestHeader;
            };
            window.fetch = function(...args) {
                const headers = args[1]?.headers;
                if (headers && (headers.Authorization || headers.authorization)) {
                    capturedAuthToken = headers.Authorization || headers.authorization;
                }
                return originalFetch.apply(this, args);
            };
            XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
                if (header.toLowerCase() === 'authorization') {
                    capturedAuthToken = value;
                }
                return originalXhrSetRequestHeader.apply(this, arguments);
            };
            let attempts = 0;
            const interval = setInterval(() => {
                if (capturedAuthToken) {
                    clearInterval(interval);
                    cleanup();
                    setCookie(AUTH_COOKIE_NAME, capturedAuthToken);
                    resolve(capturedAuthToken);
                } else if (attempts++ > 60) {
                    clearInterval(interval);
                    cleanup();
                    reject(new Error("Auth token capture timeout. Please reload the page or interact with it (e.g., mark a message as unread) to trigger a network request."));
                }
            }, 250);
        });
    };

    const generateUsefulFilename = (conversationId, aiSuffix = '') => {
        const now = new Date();
        const pad = num => num.toString().padStart(2, "0");
        const timestamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
        let headerTitle = document.querySelector('[data-test-id="conversation-header-title"]');
        let contactName = headerTitle && headerTitle.textContent.trim() ? headerTitle.textContent.trim().replace(/[^\w\s-]/g, "").trim().replace(/\s+/g, "-") : conversationId;
        const suffixPart = aiSuffix ? `_${aiSuffix}` : '';
        return `${timestamp}_${contactName}${suffixPart}_summary.txt`;
    };

    const buildDynamicPrompt = (selectedSections, customInstructions, dateFilter, imageInfo = []) => {
        let finalPrompt = "";
        if (customInstructions && customInstructions.trim() !== "") {
            finalPrompt += `SPECIAL ONE-TIME INSTRUCTION:\n${customInstructions.trim()}\n\n---\n\n`;
        }
        let dateInstruction = "";
        switch (dateFilter) {
            case "today": dateInstruction = "IMPORTANT DATE FILTER: In your analysis, you MUST only consider activities and conversations that occurred TODAY.\n\n"; break;
            case "yesterday": dateInstruction = "IMPORTANT DATE FILTER: In your analysis, you MUST only consider activities and conversations that occurred YESTERDAY. Ignore all other dates.\n\n"; break;
            case "week": dateInstruction = "IMPORTANT DATE FILTER: In your analysis, you MUST only consider activities and conversations that occurred THIS CURRENT WEEK (from last Sunday to today).\n\n"; break;
            case "last_week": dateInstruction = "IMPORTANT DATE FILTER: In your analysis, you MUST only consider activities and conversations that occurred LAST WEEK (from the Sunday before last to the following Saturday).\n\n"; break;
        }
        finalPrompt += dateInstruction;
        if (imageInfo.length > 0) {
            finalPrompt += `--- AI-GENERATED IMAGE DESCRIPTIONS (for context) ---\n${imageInfo.map(info => `Filename: ${info.newName}\nDescription: ${info.description}`).join("\n\n")}\n\n---\n\n`;
        }
        let structuredFormat = "";
        selectedSections.forEach(key => {
            if (PROMPT_SECTIONS[key]) {
                structuredFormat += PROMPT_SECTIONS[key] + "\n";
            }
        });
        return finalPrompt + BASE_PROMPT_HEADER + structuredFormat + BASE_PROMPT_FOOTER;
    };

    const runSummaryProcess = async (modelName, selectedSections, customInstructions, dateFilter) => {
        const modelInfo = MODELS.find(m => m.id === modelName);
        if (!modelInfo) return showToast("Invalid model selected.", "error");
        const geminiApiKey = await GM_getValue(GEMINI_KEY_NAME);
        const openaiApiKey = await GM_getValue(OPENAI_KEY_NAME);
        if (modelInfo.family === 'gemini' && !geminiApiKey) return showToast("Gemini API Key not set.", "error");
        if (modelInfo.family === 'openai' && !openaiApiKey) return showToast("OpenAI API Key not set.", "error");
        showToast("Starting summary process...", "success");
        try {
            let authToken = await getAuthToken();
            const conversationId = window.location.href.split("/").find(p => p.startsWith("CN"));
            if (!conversationId) throw new Error("Could not find Conversation ID in URL.");
            const openPhoneApiUrl = `https://communication.openphoneapi.com/v2/activity?id=${conversationId}&last=51`;
            let apiResponse = await gmFetch(openPhoneApiUrl, { headers: { Authorization: authToken } });
            if (apiResponse.status === 401) {
                setCookie(AUTH_COOKIE_NAME, "", -1);
                return showToast("Auth token expired. Click a 'read/unread' button, then try again.", "error");
            }
            if (!apiResponse.ok) throw new Error(`OpenPhone API request failed: ${apiResponse.status}`);
            const openPhoneData = await apiResponse.json();
            if (openPhoneData.result.length === 0) return showToast("No activities found to summarize.", "error");

            let imagePayloads = [], imageUrlList = [], imageInfo = [], aiFilenameSuffix = '';
            const allMediaItems = openPhoneData.result.flatMap(activity => Array.isArray(activity.media) ? activity.media.map(m => ({...m, from: activity.from, createdAt: activity.createdAt})) : []);
            const imageMediaItems = allMediaItems.filter(media => media && media.type && media.type.startsWith("image/"));

            if (imageMediaItems.length > 0) {
                showToast(`Found ${imageMediaItems.length} image(s). Analyzing images first...`);
                imageUrlList = imageMediaItems.map(item => item.url);
                const urlToDataUrl = async (url) => {
                    try {
                        const response = await gmFetch(url, { responseType: 'blob', headers: { Authorization: authToken } });
                        if (!response.ok) throw new Error("Fetch failed");
                        const blob = response.response;
                        return new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve({ mime: blob.type, dataUrl: reader.result });
                            reader.readAsDataURL(blob);
                        });
                    } catch (e) {
                        console.error(`Skipping image ${url}:`, e);
                        return null;
                    }
                };
                const fetchedImagePayloads = await Promise.all(imageUrlList.map(urlToDataUrl));
                imagePayloads = fetchedImagePayloads.filter(p => p);

                const imageAnalysisTextPart = { text: IMAGE_ANALYSIS_PROMPT };
                const imageAnalysisParts = imagePayloads.map(p => ({ inlineData: { mimeType: p.mime, data: p.dataUrl.split(",")[1] } }));
                const imageAnalysisPayload = { contents: [{ role: "user", parts: [imageAnalysisTextPart, ...imageAnalysisParts] }] };
                const imageAnalysisApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
                const imageAnalysisResponse = await gmFetch(imageAnalysisApiUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(imageAnalysisPayload) });

                if (imageAnalysisResponse.ok) {
                    const imageAnalysisData = await imageAnalysisResponse.json();
                    const responseText = imageAnalysisData.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    try {
                        const metadata = JSON.parse(responseText.replace(/```json|```/g, ''));
                        aiFilenameSuffix = metadata.suggested_zip_suffix || '';
                        imageInfo = imageMediaItems.map((item, index) => {
                            const details = metadata.image_details?.[index] || { description: 'N/A', suggested_filename: `image_${index+1}`};
                            const date = new Date(item.createdAt).toISOString().split('T')[0];
                            const extension = item.type.split('/')[1] || 'jpg';
                            return { url: item.url, description: details.description, newName: `${date}_${item.from}_${details.suggested_filename}.${extension}` };
                        });
                        showToast("Image analysis complete!", "success");
                    } catch (e) { console.error("Failed to parse image analysis JSON:", e); }
                } else { showToast("Image analysis failed, proceeding without it.", "error"); }
            }

            showToast("Generating final summary...", "success");
            const dynamicPrompt = buildDynamicPrompt(selectedSections, customInstructions, dateFilter, imageInfo);
            const textContent = `${dynamicPrompt}\n\n--- JSON DATA TO ANALYZE ---\n${JSON.stringify(openPhoneData, null, 2)}`;

            let initialHistory, responseText;
            const finalFilename = generateUsefulFilename(conversationId, aiFilenameSuffix);

            if (modelInfo.family === 'gemini') {
                const textPart = { text: textContent };
                const imageParts = imagePayloads.map(p => ({ inlineData: { mimeType: p.mime, data: p.dataUrl.split(",")[1] } }));
                const initialUserPayload = { role: "user", parts: [textPart, ...imageParts] };
                const geminiPayload = { contents: [initialUserPayload] };
                showToast("Sending data to Gemini...");
                const geminiFetchResponse = await gmFetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(geminiPayload) });
                if (!geminiFetchResponse.ok) throw new Error(`Gemini API Error: ${await geminiFetchResponse.text()}`);
                const geminiResponse = await geminiFetchResponse.json();
                responseText = geminiResponse.candidates?.[0]?.content?.parts?.[0]?.text;
                initialHistory = [initialUserPayload, { role: "model", parts: [{ text: responseText }] }];
            } else {
                const systemMessage = { role: "system", content: buildDynamicPrompt(selectedSections, customInstructions, dateFilter, imageInfo) };
                const userContent = [{ type: "text", text: `Here is the JSON data:\n${JSON.stringify(openPhoneData, null, 2)}` }];
                imagePayloads.forEach(p => userContent.push({ type: "image_url", image_url: { url: p.dataUrl } }));
                const userMessage = { role: "user", content: userContent };
                const openaiPayload = { model: modelName, messages: [systemMessage, userMessage], max_tokens: 4096 };
                showToast(`Sending data to ${modelInfo.displayName}...`);
                const openaiFetchResponse = await gmFetch("https://api.openai.com/v1/chat/completions", { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${openaiApiKey}` }, body: JSON.stringify(openaiPayload) });
                if (!openaiFetchResponse.ok) throw new Error(`OpenAI API Error: ${await openaiFetchResponse.text()}`);
                const openaiResponse = await openaiFetchResponse.json();
                responseText = openaiResponse.choices?.[0]?.message?.content;
                initialHistory = [{ role: 'user', parts: [{ text: textContent }] }, { role: 'model', parts: [{ text: responseText }] }];
            }
            if (!responseText) throw new Error("AI response was empty or in an unexpected format.");
            showChatModal(initialHistory, finalFilename, modelName, imageInfo);
        } catch (error) {
            console.error("❌ An error occurred:", error);
            showToast(error.message, "error");
        }
    };

    // --- STABLE INITIALIZATION LOGIC ---
    const createFloatingButton = () => {
        document.getElementById('ai-summarizer-floating-container')?.remove();
        const container = document.createElement('div');
        container.id = 'ai-summarizer-floating-container';
        container.className = 'floating-ai-button-container';
        const mainButton = document.createElement('button');
        mainButton.className = 'floating-ai-main-btn';
        mainButton.innerHTML = `${sparkleIconSVG}<span>AI Summary</span>`;
        mainButton.addEventListener('click', showExecutionOptionsModal);
        const settingsButton = document.createElement('button');
        settingsButton.className = 'floating-ai-settings-btn';
        settingsButton.innerHTML = settingsIconSVG;
        settingsButton.title = "API Key Settings";
        settingsButton.addEventListener('click', manageApiKeys);
        container.appendChild(mainButton);
        container.appendChild(settingsButton);
        document.body.appendChild(container);
        console.log("✅ Floating AI Summarizer button added.");
    };

    console.log("🚀 Initializing OpenPhone AI Summarizer (Userscript)...");
    injectStyles();
    createFloatingButton();
})();
