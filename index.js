// ==Bookmarklet Script==
// @name         OpenPhone Gemini Summarizer (Conversational)
// @description  Adds per-message buttons to generate a summary, then allows for conversational refinement in a chat window.
// @version      17.0
// @author       ilakskills
// ==/Bookmarklet Script==

(() => {
    // --- MASTER PROMPT & CONFIGURATION ---
    const PROMPT_SECTIONS = {
        title: `Title:\nDescribe the main meeting purpose or project discussed (e.g., "Project Alpha Kick-off", "Q3 Planning Session").\nDefault: If the purpose is unclear from the text, use "Interaction Summary - [Date]" (extract date from the log if possible, otherwise use current date).\n`,
        attendees: `Attendees:\nList names, inferred roles (e.g., Technician, Project Manager, Client), and companies/affiliations if identifiable.\nUse identifiers (like phone numbers) if names are unavailable.\nNote if someone was mentioned but their presence wasn't confirmed (e.g., "Jane Doe (mentioned, presence unconfirmed)").\n`,
        project_topic: `Project/Topic:\nClearly state the main project(s), work order(s), or central topic(s) of the conversation. Include relevant IDs (WO#, Ticket#, CID) if mentioned.\n`,
        discussion_points: `Content/Key Discussion Points:\nBulleted list summarizing the core substance of the conversation.\nFocus on updates provided, issues raised, problems discussed, information shared, questions asked, and context established.\nSynthesize related points, even if discussed at different times or in different interactions within the log.\n`,
        decisions: `Decisions Made:\nBulleted list of explicit agreements or conclusions reached during the interaction.\n`,
        action_items: `Follow-Up Tasks / Action Items:\nClear, actionable bullet points.\nAssign each task to a specific person/role (use name or identifier).\nInclude deadlines if mentioned.\nSpecify the action required (e.g., "Upload document," "Call client," "Investigate issue").\n`,
        notes: `Notes/Observations (Optional):\nInclude relevant observations about the interaction's tone (e.g., urgent, confused, positive), potential risks identified, unresolved questions, or general takeaways not fitting elsewhere.\n`,
        quick_summary: `Quick Summary: Sum it all up into 2 or 3 easy to understand sentances.\n`,
        quick_next_steps: `Quick Next Steps: Outline next steps in 2 or 3 easy to understand sentances.\n`,
        disclaimer: `Disclaimer:\n"Generated by AI. Please review for accuracy."\n`
    };
    
    const BASE_PROMPT_HEADER = `
Goal:
Transform a potentially messy conversation log or meeting transcript (often containing multiple interaction types like calls, texts, voicemails) into a single, clean, professional summary. The summary should effectively synthesize the entire interaction, highlighting:

Key discussion points & topics covered.
Decisions reached.
Actionable follow-up tasks with assignments.
Participants involved.
Overall context and purpose.

? Structured Output Format:
`;

    const BASE_PROMPT_FOOTER = `
? How I Work:
Synthesize & Consolidate: I read the entire conversation log, including all messages, calls, and voicemails, and synthesize the information into one cohesive summary, avoiding simple chronological listing. I consolidate redundant points.
Paraphrase & Clean: I rephrase verbatim text into professional language, correct typos/grammar, and remove filler words ("um," "uh," "like") or overly casual slang ("Kk," "Tnx").
Infer & Clarify: I infer context, relationships, and roles where possible (e.g., identifying a technician asking for support). I aim for maximum clarity even if the original text is ambiguous.
Prioritize Actionability: I focus on making decisions and follow-up tasks clear and easy to understand, highlighting who needs to do what, and when if specified.
Structure Adherence: I strictly follow the requested output format.

This updated prompt emphasizes the synthesis aspect across multiple interaction types within a log, clarifies default behaviors, and reinforces the inference capabilities expected.

Specific Instructions for this Task:
Only include information from todays interactions.
Ensure the final outcome of the interaction is clearly stated.
Do not use "USTJl43nQ9" as the name of the caller; use their phone number instead.
`;
    const API_KEY_STORAGE_NAME = 'gemini_api_key_storage';
    
    // --- SVG Icons ---
    const geminiIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 20 20"><path fill="currentColor" d="M10 2.5a.75.75 0 0 1 .75.75V4a.75.75 0 0 1-1.5 0V3.25a.75.75 0 0 1 .75-.75zM10 16a.75.75 0 0 1 .75.75v1.25a.75.75 0 0 1-1.5 0V16.75a.75.75 0 0 1 .75-.75zM5.56 4.81a.75.75 0 0 1 1.06 0l.88.88a.75.75 0 0 1-1.06 1.06l-.88-.88a.75.75 0 0 1 0-1.06zM12.5 12.5a.75.75 0 0 1 1.06 0l.88.88a.75.75 0 0 1-1.06 1.06l-.88-.88a.75.75 0 0 1 0-1.06zM2 9.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0v-1.5A.75.75 0 0 1 2 9.25zm14.25.75a.75.75 0 0 0 1.5 0v-1.5a.75.75 0 0 0-1.5 0v1.5zM5.56 14.13a.75.75 0 0 1 0-1.06l.88-.88a.75.75 0 0 1 1.06 1.06l-.88.88a.75.75 0 0 1-1.06 0zM12.5 6.56a.75.75 0 0 1 0-1.06l.88-.88a.75.75 0 1 1 1.06 1.06l-.88.88a.75.75 0 0 1-1.06 0z"></path></svg>`;
    const settingsIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="currentColor" d="M10.667 1.875A.833.833 0 0 0 10 1.25a.833.833 0 0 0-.667.625l-.234.937a5.218 5.218 0 0 0-1.593.84l-.87-.39a.833.833 0 0 0-.933.277L4.29 5.293a.833.833 0 0 0 .278.933l.794.516a5.233 5.233 0 0 0 0 1.916l-.794.516a.833.833 0 0 0-.278.933l1.414 1.414a.833.833 0 0 0 .933.278l.87-.39c.47.318.99.577 1.592.839l.234.937A.833.833 0 0 0 10 18.75a.833.833 0 0 0 .667-.625l.234-.937c.603-.262 1.122-.521 1.593-.84l.87.39a.833.833 0 0 0 .933-.277l1.414-1.414a.833.833 0 0 0-.278-.933l-.794-.516a5.233 5.233 0 0 0 0-1.916l.794-.516a.833.833 0 0 0 .278-.933L15.707 3.88a.833.833 0 0 0-.933-.278l-.87.39a5.218 5.218 0 0 0-1.592-.84l-.234-.937zM10 12.5a2.5 2.5 0 1 1 0-5a2.5 2.5 0 0 1 0 5z"></path></svg>`;
    const sendIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="currentColor" d="M2.525 2.525a.75.75 0 0 1 .91-.073l13.5 6.75a.75.75 0 0 1 0 1.196l-13.5 6.75a.75.75 0 0 1-1.002-1.123L3.89 10 2.433 3.571a.75.75 0 0 1 .092-1.046z"></path></svg>`;

    // --- UI HELPER FUNCTIONS ---
    const injectStyles = () => {
        const styleId = 'gemini-summarizer-styles';
        if (document.getElementById(styleId)) return;
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
            .gemini-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center; }
            .gemini-modal-content { background-color: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); width: 90%; max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; }
            .gemini-modal-header { padding: 16px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; } .gemini-modal-header h2 { margin: 0; font-size: 18px; color: #333; }
            .gemini-modal-close { font-size: 24px; font-weight: bold; cursor: pointer; color: #888; border: none; background: none; }
            .gemini-modal-body { padding: 16px; overflow-y: auto; font-family: sans-serif; background-color: #f9f9f9; flex-grow: 1; }
            .gemini-modal-footer { padding: 12px 16px; border-top: 1px solid #e0e0e0; display: flex; gap: 10px; justify-content: flex-end; }
            .gemini-modal-button { padding: 8px 16px; border-radius: 6px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; font-weight: 500; } .gemini-modal-button:hover { background-color: #e0e0e0; } .gemini-modal-button.primary { background-color: #007bff; color: white; border-color: #007bff; } .gemini-modal-button.primary:hover { background-color: #0056b3; }
            .gemini-toast { position: fixed; top: 20px; right: 20px; background-color: #333; color: white; padding: 12px 20px; border-radius: 6px; z-index: 10001; font-size: 14px; transition: opacity 0.5s; opacity: 1; }
            .options-modal .gemini-modal-body, .settings-modal .gemini-modal-body { white-space: normal; line-height: 1.5; background-color: #fff; }
            .settings-section { margin-bottom: 20px; } .settings-section h3 { margin:0 0 10px; border-bottom: 1px solid #eee; padding-bottom: 5px; } .settings-section label { display: block; margin-bottom: 5px; font-weight: bold; }
            .settings-section input[type="text"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
            .sections-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
            .per-message-gemini-btn { cursor: pointer; opacity: 0.3; margin-left: 8px; vertical-align: middle; border: none; background: transparent; padding: 2px; } 
            [data-testid="activity-item-actions-container"]:hover .per-message-gemini-btn { opacity: 1; }
            .chat-log { display: flex; flex-direction: column; gap: 12px; } .message-bubble { padding: 10px 14px; border-radius: 18px; max-width: 80%; line-height: 1.5; white-space: pre-wrap; word-break: break-word; } .message-bubble.user { background-color: #007bff; color: white; align-self: flex-end; } .message-bubble.model { background-color: #e9e9eb; color: #1c1c1e; align-self: flex-start; } .message-bubble.loading { align-self: flex-start; } .message-bubble.error { background-color: #ffcccc; color: #a00; }
            .chat-input-form { display: flex; gap: 10px; padding: 10px 16px; border-top: 1px solid #e0e0e0; } #chat-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 20px; } #chat-send-btn { background: #007bff; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; }
        `;
        document.head.appendChild(style);
    };
    const showToast = (message, type = 'success') => {
        const toast = document.createElement('div');
        toast.className = `gemini-toast ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 500);
        }, 3000);
    };
    const showApiKeyModal = () => {
        const overlay = document.createElement('div');
        overlay.className = 'gemini-modal-overlay settings-modal';
        const currentKey = localStorage.getItem(API_KEY_STORAGE_NAME) || '';
        overlay.innerHTML = `
            <div class="gemini-modal-content" style="max-width: 500px;">
                <div class="gemini-modal-header"><h2>API Key Settings</h2><button class="gemini-modal-close">×</button></div>
                <div class="gemini-modal-body">
                    <div class="settings-section">
                        <label for="apiKey">Gemini API Key</label>
                        <input type="text" id="apiKey" value="${currentKey}" placeholder="Enter your key here">
                        <p style="font-size:12px; color:#666; margin-top:8px;">Your key is stored in your browser's local storage.</p>
                    </div>
                </div>
                <div class="gemini-modal-footer">
                    <button class="gemini-modal-button primary" id="save-key">Save Key</button>
                </div>
            </div>`;
        document.body.appendChild(overlay);
        const closeModal = () => overlay.remove();
        overlay.querySelector('.gemini-modal-close').addEventListener('click', closeModal);
        overlay.querySelector('#save-key').addEventListener('click', () => {
            const newKey = overlay.querySelector('#apiKey').value.trim();
            if (newKey) {
                localStorage.setItem(API_KEY_STORAGE_NAME, newKey);
                showToast('API Key saved successfully!');
            } else {
                localStorage.removeItem(API_KEY_STORAGE_NAME);
                showToast('API Key cleared.', 'error');
            }
            closeModal();
        });
    };

    const showChatModal = (initialHistory, filename) => {
        let chatHistory = [...initialHistory];
        const overlay = document.createElement('div');
        overlay.className = 'gemini-modal-overlay chat-modal';
        overlay.innerHTML = `
            <div class="gemini-modal-content">
                <div class="gemini-modal-header"><h2>AI Summary & Refinement</h2><button class="gemini-modal-close">×</button></div>
                <div class="gemini-modal-body"><div class="chat-log"></div></div>
                <form class="chat-input-form">
                    <input type="text" id="chat-input" placeholder="Refine the summary..." autocomplete="off">
                    <button type="submit" id="chat-send-btn" title="Send">${sendIconSVG}</button>
                </form>
                <div class="gemini-modal-footer">
                    <button class="gemini-modal-button download-btn">Download Last</button>
                    <button class="gemini-modal-button primary copy-btn">Copy Last</button>
                </div>
            </div>`;
        document.body.appendChild(overlay);

        const chatLog = overlay.querySelector('.chat-log');
        const chatInput = overlay.querySelector('#chat-input');
        const chatForm = overlay.querySelector('.chat-input-form');
        const closeModal = () => overlay.remove();

        const appendMessage = (sender, text) => {
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${sender}`;
            bubble.textContent = text;
            chatLog.appendChild(bubble);
            chatLog.scrollTop = chatLog.scrollHeight;
            return bubble;
        };
        
        const initialAiResponse = chatHistory.find(h => h.role === 'model')?.parts[0]?.text;
        if (initialAiResponse) appendMessage('model', initialAiResponse);

        const sendChatMessage = async (message) => {
            appendMessage('user', message);
            chatInput.value = '';
            const loadingBubble = appendMessage('model loading', '...');
            
            chatHistory.push({ role: 'user', parts: [{ text: message }] });
            
            try {
                const apiKey = localStorage.getItem(API_KEY_STORAGE_NAME);
                const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
                const payload = { contents: chatHistory };
                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API Error: ${await response.text()}`);
                const data = await response.json();
                const newText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!newText) throw new Error("Received an empty response from AI.");
                
                chatHistory.push({ role: 'model', parts: [{ text: newText }] });
                loadingBubble.remove();
                appendMessage('model', newText);
            } catch(error) {
                loadingBubble.remove();
                appendMessage('error', `Error: ${error.message}`);
                console.error(error);
            }
        };

        chatForm.addEventListener('submit', (e) => { e.preventDefault(); const message = chatInput.value.trim(); if (message) sendChatMessage(message); });
        overlay.querySelector('.gemini-modal-close').addEventListener('click', closeModal);
        overlay.querySelector('.copy-btn').addEventListener('click', () => {
            const lastModelResponse = chatLog.querySelector('.message-bubble.model:last-child');
            if (lastModelResponse) navigator.clipboard.writeText(lastModelResponse.textContent).then(() => showToast('Copied to clipboard!'));
        });
        overlay.querySelector('.download-btn').addEventListener('click', () => {
             const lastModelResponse = chatLog.querySelector('.message-bubble.model:last-child');
             if (lastModelResponse) {
                const blob = new Blob([lastModelResponse.textContent], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
             }
        });
    };
    
    // --- CORE LOGIC & MODALS ---
    const showExecutionOptionsModal = (activityId) => {
        const overlay = document.createElement('div');
        overlay.className = 'gemini-modal-overlay options-modal';
        const sectionsHtml = Object.keys(PROMPT_SECTIONS).map(key => `<label><input type="checkbox" name="section" value="${key}" checked>${key.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase())}</label>`).join('');

        overlay.innerHTML = `
            <div class="gemini-modal-content">
                <div class="gemini-modal-header"><h2>Generate Summary Options</h2><button class="gemini-modal-close">×</button></div>
                <div class="gemini-modal-body">
                    <div class="settings-section">
                        <h3>Output Sections</h3>
                        <div class="sections-grid">${sectionsHtml}</div>
                    </div>
                </div>
                <div class="gemini-modal-footer">
                    <button class="gemini-modal-button" id="cancel-run">Cancel</button>
                    <button class="gemini-modal-button primary" id="generate-summary">Generate Summary</button>
                </div>
            </div>`;
        document.body.appendChild(overlay);

        const closeModal = () => overlay.remove();
        overlay.querySelector('.gemini-modal-close').addEventListener('click', closeModal);
        overlay.querySelector('#cancel-run').addEventListener('click', closeModal);
        overlay.querySelector('#generate-summary').addEventListener('click', () => {
            const selectedSections = Array.from(overlay.querySelectorAll('input[name="section"]:checked')).map(el => el.value);
            closeModal();
            runSummaryProcess(activityId, selectedSections);
        });
    };

    const getAuthToken = () => { return new Promise((resolve,reject)=>{let e=null;const t=window.fetch,n=XMLHttpRequest.prototype.setRequestHeader;const o=()=>{window.fetch=t,XMLHttpRequest.prototype.setRequestHeader=n};window.fetch=function(...n){const s=n[1]?.headers;return s&&(s.Authorization||s.authorization)&&(e=s.Authorization||s.authorization),t.apply(this,n)},XMLHttpRequest.prototype.setRequestHeader=function(t,s){"authorization"===t.toLowerCase()&&(e=s);return n.apply(this,arguments)};let s=0;const i=setInterval(()=>{e?(clearInterval(i),o(),resolve(e)):s++>150&&(clearInterval(i),o(),reject(new Error("Auth token timeout. Please refresh and try again.")))},100)})};
    const generateUsefulFilename = (conversationId) => { const e=new Date,t=e=>e.toString().padStart(2,"0"),n=`${e.getFullYear()}-${t(e.getMonth()+1)}-${t(e.getDate())}_${t(e.getHours())}-${t(e.getMinutes())}`;let o=document.querySelector('[data-test-id="conversation-header-title"]');return o=o&&o.textContent.trim()?o.textContent.trim().replace(/[^\w\s-]/g,"").trim().replace(/\s+/g,"-"):conversationId,`${n}_${o}_OpenPhone_Summary.txt`};
    const buildDynamicPrompt = (selectedSections) => {
        let structuredFormat = '';
        selectedSections.forEach(key => { if (PROMPT_SECTIONS[key]) structuredFormat += PROMPT_SECTIONS[key] + '\n'; });
        return BASE_PROMPT_HEADER + structuredFormat + BASE_PROMPT_FOOTER;
    };
    const runSummaryProcess = async (activityId, selectedSections) => {
        const apiKey = localStorage.getItem(API_KEY_STORAGE_NAME);
        if (!apiKey) { showToast("API Key not set. Please set it in Settings (gear icon).", 'error'); return; }
        showToast("Starting summary process...", 'success');
        try {
            const authToken = await getAuthToken();
            const currentUrl = window.location.href;
            const conversationId = currentUrl.split('/').pop() || currentUrl.split('/').slice(-2)[0];
            if (!conversationId || !conversationId.startsWith('CN')) throw new Error(`Invalid Conversation ID: "${conversationId}"`);
            
            const openPhoneApiUrl = `https://communication.openphoneapi.com/v2/activity?id=${conversationId}&last=51&before=${activityId}`;
            const apiResponse = await fetch(openPhoneApiUrl, { headers: { 'Authorization': authToken } });
            if (!apiResponse.ok) throw new Error(`OpenPhone API request failed: ${apiResponse.status}`);
            const openPhoneData = await apiResponse.json();
            if (openPhoneData.result.length === 0) { showToast("No activities found before the selected message.", 'error'); return; }

            const dynamicPrompt = buildDynamicPrompt(selectedSections);
            const imageParts = [];
            const textPart = { text: dynamicPrompt + JSON.stringify(openPhoneData, null, 2) };
            const imageActivities = openPhoneData.result.filter(activity => activity.media?.some(m => m.type.startsWith('image/')));
            if (imageActivities.length > 0) { showToast(`Found ${imageActivities.length} image(s). Fetching...`);const e=async t=>{try{const e=await fetch(t.url);if(!e.ok)throw new Error(`Failed to fetch image: ${e.statusText}`);const n=await e.blob();return new Promise((e,o)=>{const s=new FileReader;s.onloadend=()=>{const t=s.result.split(",")[1];e({inlineData:{mimeType:n.type,data:t}})},s.onerror=o,s.readAsDataURL(n)})}catch(e){return console.error(`Skipping image ${t.url} due to error:`,e),null}};const t=imageActivities.flatMap(t=>t.media.map(e));const n=await Promise.all(t);imageParts.push(...n.filter(e=>null!==e)) }

            const initialUserPayload = { role: 'user', parts: [textPart, ...imageParts] };
            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;
            const geminiPayload = { contents: [initialUserPayload] };
            
            showToast("Sending initial data to Gemini...");
            const geminiFetchResponse = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(geminiPayload) });
            if (!geminiFetchResponse.ok) throw new Error(`Gemini API request failed: ${await geminiFetchResponse.text()}`);
            const geminiResponse = await geminiFetchResponse.json();
            const geminiResponseText = geminiResponse.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!geminiResponseText) throw new Error("Gemini response was empty or in an unexpected format.");
            
            const finalFilename = generateUsefulFilename(conversationId);
            const chatHistory = [initialUserPayload, { role: 'model', parts: [{ text: geminiResponseText }] }];
            
            showChatModal(chatHistory, finalFilename);
        } catch (error) {
            console.error("❌ An error occurred:", error);
            showToast(error.message, 'error');
        }
    };
    
    // --- UI INJECTION & OBSERVER LOGIC ---
    const setupObserversAndInjectUI = () => {
        const addButtonToMessage = (actionContainer) => {
            if (actionContainer.querySelector('.per-message-gemini-btn')) return;
            const activityItem = actionContainer.closest('[data-testid="activity-list-item"]');
            if (!activityItem || !activityItem.id) return;
            const activityId = activityItem.id;

            const btn = document.createElement('button');
            btn.className = 'per-message-gemini-btn';
            btn.title = "Summarize up to this point";
            btn.innerHTML = geminiIconSVG;
            btn.addEventListener('click', (e) => { e.stopPropagation(); e.preventDefault(); showExecutionOptionsModal(activityId); });
            actionContainer.prepend(btn);
        };

        const conversationObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                for (const node of mutation.addedNodes) {
                    if (node.nodeType === 1) {
                        const containers = node.querySelectorAll('[data-testid="activity-item-actions-container"]');
                        containers.forEach(addButtonToMessage);
                    }
                }
            }
        });
        
        const targetNode = document.querySelector('[data-testid="virtualized-conversation-list"]');
        if (targetNode) {
            conversationObserver.observe(targetNode, { childList: true, subtree: true });
            targetNode.querySelectorAll('[data-testid="activity-item-actions-container"]').forEach(addButtonToMessage);
            console.log("✅ Per-message button observer is active.");
        } else { console.error("❌ Could not find conversation list to attach observer."); }

        const quickActionObserver = new MutationObserver((mutations, obs) => {
            const targetContainer = document.getElementById('message-quick-actions');
            if (targetContainer) {
                const templateButton = targetContainer.querySelector('button');
                if (templateButton && !document.getElementById('gemini-settings-button')) {
                    const settingsButton = templateButton.cloneNode(true);
                    settingsButton.id = 'gemini-settings-button';
                    settingsButton.innerHTML = settingsIconSVG;
                    settingsButton.title = "API Key Settings";
                    settingsButton.removeAttribute('aria-labelledby');
                    settingsButton.addEventListener('click', showApiKeyModal);
                    targetContainer.prepend(settingsButton);
                    console.log("✅ Settings gear button successfully added.");
                    obs.disconnect();
                }
            }
        });
        quickActionObserver.observe(document.body, { childList: true, subtree: true });
    };
    
    injectStyles();
    setupObserversAndInjectUI();
})();
